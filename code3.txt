res://axiom-runtime-/core/metadata/BindingGenerator.gd

## BindingGenerator.gd
## Directory: /axiom-runtime-/core/metadata/BindingGenerator.gd
##

## BindingGenerator.gd
## Phase 5: Metadata & Code Generation - GDScript binding generator
## Directory: /core/metadata/BindingGenerator.gd
##
## CRITICAL: Generates type-safe bindings from contracts
## Generated code is semantic at mod level, but generator is semantic-free
## Core only templates and writes files
##
## UPDATED: Now supports custom contract types via generic binding generation

extends Node

const VERSION = "1.1.0"  # Updated for custom contract type support

## Generation result
class GenerationResult:
	var success: bool
	var generated_files: Array[String]
	var errors: Array[String]
	var warnings: Array[String]
	
	func _init():
		success = false
		generated_files = []
		errors = []
		warnings = []
	
	func add_error(msg: String) -> void:
		errors.append(msg)
		success = false
	
	func add_warning(msg: String) -> void:
		warnings.append(msg)
	
	func add_file(path: String) -> void:
		generated_files.append(path)


## ============================================================================
## INITIALIZATION
## ============================================================================

func _ready() -> void:
	LoggingService.info(LoggingService.Context.CORE, "BindingGenerator", "Initialized v%s" % VERSION)
	LoggingService.info(LoggingService.Context.CORE, "BindingGenerator", "Supports custom contract types")


## ============================================================================
## BINDING GENERATION
## ============================================================================

func generate_bindings(coremod_metadata: Dictionary, id_map: Dictionary, output_dir: String) -> GenerationResult:
	"""
	Generate GDScript bindings from CoreMod contracts.
	
	UPDATED: Now handles both known and custom contract types.
	
	Args:
		coremod_metadata: Parsed CoreMod metadata
		id_map: ID mapping from IDGenerator
		output_dir: Output directory for generated files
	
	Returns:
		GenerationResult with success status and file list
	"""
	
	LoggingService.info(LoggingService.Context.CORE, "BindingGenerator", "Generating bindings...")
	
	var result = GenerationResult.new()
	
	if not coremod_metadata.has("contracts"):
		result.add_error("No contracts to generate bindings from")
		return result
	
	var contracts = coremod_metadata["contracts"]
	var coremod_id = coremod_metadata.get("id", "unknown")
	
	# Ensure output directory exists
	if not _ensure_directory(output_dir):
		result.add_error("Cannot create output directory: %s" % output_dir)
		return result
	
	# Generate bindings for each contract type
	for contract_type in contracts.keys():
		var contract_list = contracts[contract_type]
		
		if typeof(contract_list) != TYPE_ARRAY or contract_list.is_empty():
			continue
		
		# Dispatch to type-specific or generic generator
		match contract_type:
			"events":
				_generate_event_bindings(contract_list, id_map, coremod_id, output_dir, result)
			"systems":
				_generate_system_bindings(contract_list, id_map, coremod_id, output_dir, result)
			"registries":
				_generate_registry_bindings(contract_list, id_map, coremod_id, output_dir, result)
			_:
				# ADDED: Generic binding generation for custom types
				_generate_generic_bindings(contract_type, contract_list, id_map, coremod_id, output_dir, result)
	
	# Generate main binding file
	_generate_main_binding(coremod_metadata, id_map, output_dir, result)
	
	result.success = result.errors.is_empty()
	
	if result.success:
		LoggingService.info(LoggingService.Context.CORE, "BindingGenerator", "âœ“ Generated %d binding files" % result.generated_files.size())
	else:
		LoggingService.error(LoggingService.Context.CORE, "BindingGenerator", "âœ— Binding generation failed")
	
	return result


## ============================================================================
## EVENT BINDINGS
## ============================================================================

func _generate_event_bindings(events: Array, id_map: Dictionary, coremod_id: String, output_dir: String, result: GenerationResult) -> void:
	"""
	Generate event binding file.
	"""
	
	var file_path = output_dir.path_join("EventBindings.gd")
	var code = ""
	
	# File header
	code += "## EventBindings.gd\n"
	code += "## Auto-generated event bindings for %s\n" % coremod_id
	code += "## DO NOT EDIT - Generated by BindingGenerator\n"
	code += "\n"
	code += "extends RefCounted\n"
	code += "\n"
	code += "## Event IDs\n"
	
	# Generate event constants
	for event in events:
		if typeof(event) != TYPE_DICTIONARY:
			continue
		
		var event_id = event.get("id", "")
		if event_id == "":
			continue
		
		var generated_id = id_map.get(event_id, event_id)
		var const_name = event_id.to_upper()
		
		code += "const EVENT_%s = \"%s\"\n" % [const_name, generated_id]
	
	code += "\n"
	code += "## Event subscription helpers\n"
	code += "\n"
	
	# Generate subscription methods
	for event in events:
		if typeof(event) != TYPE_DICTIONARY:
			continue
		
		var event_id = event.get("id", "")
		if event_id == "":
			continue
		
		var generated_id = id_map.get(event_id, event_id)
		var method_name = "subscribe_" + event_id
		var const_name = "EVENT_" + event_id.to_upper()
		
		code += "static func %s(callback: Callable, subscriber_id: String) -> Variant:\n" % method_name
		code += "\treturn EventBus.subscribe(%s, callback, subscriber_id)\n" % const_name
		code += "\n"
	
	# Write file
	if _write_file(file_path, code):
		result.add_file(file_path)
		LoggingService.debug(LoggingService.Context.CORE, "BindingGenerator", "Generated: EventBindings.gd")
	else:
		result.add_error("Failed to write EventBindings.gd")


## ============================================================================
## SYSTEM BINDINGS
## ============================================================================

func _generate_system_bindings(systems: Array, id_map: Dictionary, coremod_id: String, output_dir: String, result: GenerationResult) -> void:
	"""
	Generate system binding file.
	"""
	
	var file_path = output_dir.path_join("SystemBindings.gd")
	var code = ""
	
	# File header
	code += "## SystemBindings.gd\n"
	code += "## Auto-generated system bindings for %s\n" % coremod_id
	code += "## DO NOT EDIT - Generated by BindingGenerator\n"
	code += "\n"
	code += "extends RefCounted\n"
	code += "\n"
	code += "## System IDs\n"
	
	# Generate system constants
	for system in systems:
		if typeof(system) != TYPE_DICTIONARY:
			continue
		
		var system_id = system.get("id", "")
		if system_id == "":
			continue
		
		var generated_id = id_map.get(system_id, system_id)
		var const_name = system_id.to_upper()
		
		code += "const SYSTEM_%s = \"%s\"\n" % [const_name, generated_id]
	
	code += "\n"
	code += "## System override helpers\n"
	code += "\n"
	
	# Generate override methods (only for overrideable systems)
	for system in systems:
		if typeof(system) != TYPE_DICTIONARY:
			continue
		
		var system_id = system.get("id", "")
		var overrideable = system.get("overrideable", false)
		
		if system_id == "" or not overrideable:
			continue
		
		var const_name = "SYSTEM_" + system_id.to_upper()
		var method_name = "override_" + system_id
		
		code += "## Override %s system\n" % system_id
		code += "## WARNING: This replaces the default system behavior\n"
		code += "static func %s(handler: Callable) -> void:\n" % method_name
		code += "\t# Implementation depends on CoreMod's override mechanism\n"
		code += "\tpass\n"
		code += "\n"
	
	# Write file
	if _write_file(file_path, code):
		result.add_file(file_path)
		LoggingService.debug(LoggingService.Context.CORE, "BindingGenerator", "Generated: SystemBindings.gd")
	else:
		result.add_error("Failed to write SystemBindings.gd")


## ============================================================================
## REGISTRY BINDINGS
## ============================================================================

func _generate_registry_bindings(registries: Array, id_map: Dictionary, coremod_id: String, output_dir: String, result: GenerationResult) -> void:
	"""
	Generate registry binding file.
	"""
	
	var file_path = output_dir.path_join("RegistryBindings.gd")
	var code = ""
	
	# File header
	code += "## RegistryBindings.gd\n"
	code += "## Auto-generated registry bindings for %s\n" % coremod_id
	code += "## DO NOT EDIT - Generated by BindingGenerator\n"
	code += "\n"
	code += "extends RefCounted\n"
	code += "\n"
	code += "## Registry IDs\n"
	
	# Generate registry constants
	for registry in registries:
		if typeof(registry) != TYPE_DICTIONARY:
			continue
		
		var registry_id = registry.get("id", "")
		if registry_id == "":
			continue
		
		var generated_id = id_map.get(registry_id, registry_id)
		var const_name = registry_id.to_upper()
		
		code += "const REGISTRY_%s = \"%s\"\n" % [const_name, generated_id]
	
	code += "\n"
	code += "## Registry access helpers\n"
	code += "\n"
	
	# Generate registry access methods
	for registry in registries:
		if typeof(registry) != TYPE_DICTIONARY:
			continue
		
		var registry_id = registry.get("id", "")
		if registry_id == "":
			continue
		
		var const_name = "REGISTRY_" + registry_id.to_upper()
		var get_method = "get_" + registry_id
		var extend_method = "extend_" + registry_id
		
		# Get method
		code += "static func %s(entry_id: String) -> Variant:\n" % get_method
		code += "\t# Access registry entry\n"
		code += "\t# Implementation depends on CoreMod's registry system\n"
		code += "\treturn null\n"
		code += "\n"
		
		# Extend method (only for extensible registries)
		if registry.get("extensible", false):
			code += "static func %s(entry_id: String, data: Variant) -> bool:\n" % extend_method
			code += "\t# Register new entry in registry\n"
			code += "\t# Implementation depends on CoreMod's registry system\n"
			code += "\treturn false\n"
			code += "\n"
	
	# Write file
	if _write_file(file_path, code):
		result.add_file(file_path)
		LoggingService.debug(LoggingService.Context.CORE, "BindingGenerator", "Generated: RegistryBindings.gd")
	else:
		result.add_error("Failed to write RegistryBindings.gd")


## ============================================================================
## GENERIC BINDINGS (Custom Contract Types)
## ============================================================================

func _generate_generic_bindings(contract_type: String, contracts: Array, id_map: Dictionary, coremod_id: String, output_dir: String, result: GenerationResult) -> void:
	"""
	ADDED: Generate generic bindings for custom contract types.
	
	For custom types (e.g., "quests", "achievements"), generates:
	- Constants for each contract ID
	- Generic access helper methods
	"""
	
	LoggingService.debug(LoggingService.Context.CORE, "BindingGenerator", 
		"Generating generic bindings for custom type: '%s'" % contract_type)
	
	# Convert type name to PascalCase for filename
	var binding_class_name = _to_pascal_case(contract_type) + "Bindings"
	var file_path = output_dir.path_join(binding_class_name + ".gd")
	
	var code = ""
	
	# File header
	code += "## %s.gd\n" % binding_class_name
	code += "## Auto-generated bindings for custom contract type: %s\n" % contract_type
	code += "## CoreMod: %s\n" % coremod_id
	code += "## DO NOT EDIT - Generated by BindingGenerator\n"
	code += "\n"
	code += "extends RefCounted\n"
	code += "\n"
	code += "## %s IDs\n" % contract_type.capitalize()
	
	# Generate constants
	for contract in contracts:
		if typeof(contract) != TYPE_DICTIONARY:
			continue
		
		var contract_id = contract.get("id", "")
		if contract_id == "":
			continue
		
		var generated_id = id_map.get(contract_id, contract_id)
		var const_name = contract_id.to_upper()
		
		code += "const %s_%s = \"%s\"\n" % [contract_type.to_upper(), const_name, generated_id]
	
	code += "\n"
	code += "## Generic access helpers for %s\n" % contract_type
	code += "\n"
	
	# Generate generic access methods
	for contract in contracts:
		if typeof(contract) != TYPE_DICTIONARY:
			continue
		
		var contract_id = contract.get("id", "")
		if contract_id == "":
			continue
		
		var const_name = "%s_%s" % [contract_type.to_upper(), contract_id.to_upper()]
		var access_method = "access_" + contract_id
		
		code += "## Access %s contract: %s\n" % [contract_type, contract_id]
		code += "## This is a generic binding - implementation depends on CoreMod\n"
		code += "static func %s() -> String:\n" % access_method
		code += "\treturn %s\n" % const_name
		code += "\n"
	
	code += "## Get all %s IDs\n" % contract_type
	code += "static func get_all_ids() -> Array[String]:\n"
	code += "\treturn [\n"
	for contract in contracts:
		if typeof(contract) != TYPE_DICTIONARY:
			continue
		var contract_id = contract.get("id", "")
		if contract_id == "":
			continue
		var const_name = "%s_%s" % [contract_type.to_upper(), contract_id.to_upper()]
		code += "\t\t%s,\n" % const_name
	code += "\t]\n"
	code += "\n"
	
	# Write file
	if _write_file(file_path, code):
		result.add_file(file_path)
		LoggingService.debug(LoggingService.Context.CORE, "BindingGenerator", 
			"Generated: %s.gd (custom type)" % binding_class_name)
	else:
		result.add_error("Failed to write %s.gd" % binding_class_name)


## ============================================================================
## MAIN BINDING FILE
## ============================================================================

func _generate_main_binding(coremod_metadata: Dictionary, id_map: Dictionary, output_dir: String, result: GenerationResult) -> void:
	"""
	Generate main binding file that imports all others.
	
	UPDATED: Now includes custom contract type bindings.
	"""
	
	var file_path = output_dir.path_join("CoreModBindings.gd")
	var coremod_id = coremod_metadata.get("id", "unknown")
	var coremod_version = coremod_metadata.get("version", "unknown")
	
	var code = ""
	
	# File header
	code += "## CoreModBindings.gd\n"
	code += "## Auto-generated bindings for %s v%s\n" % [coremod_id, coremod_version]
	code += "## DO NOT EDIT - Generated by BindingGenerator\n"
	code += "\n"
	code += "extends RefCounted\n"
	code += "\n"
	code += "## CoreMod information\n"
	code += "const COREMOD_ID = \"%s\"\n" % coremod_id
	code += "const COREMOD_VERSION = \"%s\"\n" % coremod_version
	code += "\n"
	code += "## Generated bindings\n"
	
	# Import known types
	var contracts = coremod_metadata.get("contracts", {})
	
	if contracts.has("events"):
		code += "const EventBindings = preload(\"res://generated/%s/EventBindings.gd\")\n" % coremod_id
	
	if contracts.has("systems"):
		code += "const SystemBindings = preload(\"res://generated/%s/SystemBindings.gd\")\n" % coremod_id
	
	if contracts.has("registries"):
		code += "const RegistryBindings = preload(\"res://generated/%s/RegistryBindings.gd\")\n" % coremod_id
	
	# ADDED: Import custom types
	for contract_type in contracts.keys():
		if contract_type not in ["events", "systems", "registries"]:
			var binding_class_name = _to_pascal_case(contract_type) + "Bindings"
			code += "const %s = preload(\"res://generated/%s/%s.gd\")\n" % [binding_class_name, coremod_id, binding_class_name]
	
	code += "\n"
	code += "## Quick access to bindings\n"
	
	if contracts.has("events"):
		code += "static var Events = EventBindings\n"
	
	if contracts.has("systems"):
		code += "static var Systems = SystemBindings\n"
	
	if contracts.has("registries"):
		code += "static var Registries = RegistryBindings\n"
	
	# ADDED: Quick access to custom types
	for contract_type in contracts.keys():
		if contract_type not in ["events", "systems", "registries"]:
			var binding_class_name = _to_pascal_case(contract_type) + "Bindings"
			var var_name = _to_pascal_case(contract_type)
			code += "static var %s = %s\n" % [var_name, binding_class_name]
	
	# Write file
	if _write_file(file_path, code):
		result.add_file(file_path)
		LoggingService.debug(LoggingService.Context.CORE, "BindingGenerator", "Generated: CoreModBindings.gd")
	else:
		result.add_error("Failed to write CoreModBindings.gd")


## ============================================================================
## FILE OPERATIONS
## ============================================================================

func _ensure_directory(path: String) -> bool:
	"""
	Ensure directory exists.
	"""
	
	if DirAccess.dir_exists_absolute(path):
		return true
	
	var dir = DirAccess.open("/")
	if not dir:
		return false
	
	var err = dir.make_dir_recursive(path)
	return err == OK or DirAccess.dir_exists_absolute(path)


func _write_file(path: String, content: String) -> bool:
	"""
	Write content to file.
	"""
	
	var file = FileAccess.open(path, FileAccess.WRITE)
	if not file:
		return false
	
	file.store_string(content)
	file.close()
	
	return true


## ============================================================================
## STRING UTILITIES
## ============================================================================

func _to_pascal_case(snake_case: String) -> String:
	"""
	Convert snake_case to PascalCase.
	Example: "quest_system" -> "QuestSystem"
	"""
	
	var parts = snake_case.split("_")
	var result = ""
	
	for part in parts:
		if part.length() > 0:
			result += part.capitalize()
	
	return result


## ============================================================================
## DIAGNOSTICS
## ============================================================================

func get_version() -> String:
	return VERSION


func format_generation_result(result: GenerationResult) -> String:
	"""
	Format generation result for logging.
	"""
	
	var output = ""
	output += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"
	output += "   BINDING GENERATION RESULT\n"
	output += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"
	output += "Success:  %s\n" % str(result.success)
	output += "Files:    %d\n" % result.generated_files.size()
	output += "Errors:   %d\n" % result.errors.size()
	output += "Warnings: %d\n" % result.warnings.size()
	output += "\n"
	
	if not result.errors.is_empty():
		output += "ERRORS:\n"
		for error in result.errors:
			output += "  âœ— %s\n" % error
		output += "\n"
	
	if not result.warnings.is_empty():
		output += "WARNINGS:\n"
		for warning in result.warnings:
			output += "  âš  %s\n" % warning
		output += "\n"
	
	if not result.generated_files.is_empty():
		output += "GENERATED FILES:\n"
		for file in result.generated_files:
			output += "  âœ“ %s\n" % file
	
	output += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"
	
	return output


res://axiom-runtime-/core/metadata/BindingGenerator.gd.uid

## BindingGenerator.gd.uid
## Directory: /axiom-runtime-/core/metadata/BindingGenerator.gd.uid
##

uid://du2p04o5ssdbs


res://axiom-runtime-/core/metadata/ContractValidator.gd

## ContractValidator.gd
## Directory: /axiom-runtime-/core/metadata/ContractValidator.gd
##

## ContractValidator.gd
## Phase 5: Metadata & Code Generation - Contract completeness validation
## Directory: /core/metadata/ContractValidator.gd
##
## CRITICAL: Validates contract completeness for "everything is moddable" guarantee
## Ensures no modding surfaces are missed
## Core validates structure only, not semantics
##
## FIXED: Option 4 - Hybrid validation (suggestions + discovery)
## - Core suggests common types but doesn't enforce them
## - CoreMods can define any contract types they want
## - Validates known types deeply, unknown types generically
## - Provides helpful guidance without restricting CoreMods

extends Node

const VERSION = "1.1.0"  # Updated for Option 4 implementation

## CONTRACT TYPE SUGGESTIONS (Not Requirements!)
## CoreMods can use these or define their own types freely
const CONTRACT_TYPE_SUGGESTIONS = {
	"common_types": ["events", "systems"],  # Commonly used, not required
	"optional_types": ["registries", "ui", "save_hooks", "quests", "achievements", "minigames"]
}

## Validation result for contract completeness
class CompletenessResult:
	var complete: bool
	var missing_contracts: Array[String]
	var warnings: Array[String]
	var contract_count: int
	var coverage_percentage: float
	var discovered_types: Array[String]  # ADDED: Track what types CoreMod actually uses
	
	func _init():
		complete = false
		missing_contracts = []
		warnings = []
		contract_count = 0
		coverage_percentage = 0.0
		discovered_types = []
	
	func add_missing(contract_id: String) -> void:
		missing_contracts.append(contract_id)
		complete = false
	
	func add_warning(msg: String) -> void:
		warnings.append(msg)


## ============================================================================
## INITIALIZATION
## ============================================================================

func _ready() -> void:
	LoggingService.info(LoggingService.Context.CORE, "ContractValidator", "Initialized v%s" % VERSION)
	LoggingService.info(LoggingService.Context.CORE, "ContractValidator", "Using hybrid validation (suggestions + discovery)")


## ============================================================================
## CONTRACT COMPLETENESS VALIDATION
## ============================================================================

func validate_completeness(coremod_metadata: Dictionary) -> CompletenessResult:
	"""
	Validate that CoreMod has exposed all modding surfaces.
	Checks for contract completeness without semantic interpretation.
	
	FIXED: Now uses hybrid validation:
	- Suggests common types (warnings, not errors)
	- Accepts any contract types CoreMod defines
	- Validates known types deeply, unknown types generically
	
	Args:
		coremod_metadata: Parsed CoreMod metadata
	
	Returns:
		CompletenessResult with validation details
	"""
	
	LoggingService.info(LoggingService.Context.CORE, "ContractValidator", "Validating contract completeness...")
	
	var result = CompletenessResult.new()
	
	if not coremod_metadata.has("contracts"):
		result.add_missing("No contracts defined")
		return result
	
	var contracts = coremod_metadata["contracts"]
	
	# FIXED: Validate with suggestions, not requirements
	_validate_contract_types_hybrid(contracts, result)
	
	# Validate each discovered contract type
	for contract_type in contracts.keys():
		if typeof(contracts[contract_type]) != TYPE_ARRAY:
			result.add_missing("Contract type '%s' must be an array" % contract_type)
			continue
		
		# Track discovered type
		result.discovered_types.append(contract_type)
		
		# Dispatch to type-specific or generic validation
		_validate_contract_type(contract_type, contracts[contract_type], result)
	
	# Calculate coverage
	_calculate_coverage(contracts, result)
	
	# Determine if complete (no missing contracts, only warnings allowed)
	result.complete = result.missing_contracts.is_empty()
	
	if result.complete:
		LoggingService.info(LoggingService.Context.CORE, "ContractValidator", "âœ“ Contract completeness validated (%.1f%% coverage)" % result.coverage_percentage)
	else:
		LoggingService.warn(LoggingService.Context.CORE, "ContractValidator", "âš  Incomplete contracts - %d missing" % result.missing_contracts.size())
	
	return result


func _validate_contract_types_hybrid(contracts: Dictionary, result: CompletenessResult) -> void:
	"""
	FIXED: Hybrid validation - suggestions without enforcement.
	
	CoreMods can define any contract types they want.
	Core provides helpful suggestions but doesn't enforce them.
	"""
	
	if contracts.is_empty():
		result.add_missing("No contract types defined")
		return
	
	# Info: What types CoreMod defined
	var defined_types = contracts.keys()
	LoggingService.info(LoggingService.Context.CORE, "ContractValidator", 
		"CoreMod defines %d contract types: %s" % [defined_types.size(), ", ".join(defined_types)])
	
	# SUGGESTION (not requirement): Common types
	for common_type in CONTRACT_TYPE_SUGGESTIONS["common_types"]:
		if not contracts.has(common_type) or contracts[common_type].is_empty():
			result.add_warning("ðŸ’¡ Suggestion: Consider adding '%s' contracts (commonly used for modding)" % common_type)
	
	# Check for recognized optional types
	for optional_type in CONTRACT_TYPE_SUGGESTIONS["optional_types"]:
		if contracts.has(optional_type) and not contracts[optional_type].is_empty():
			LoggingService.debug(LoggingService.Context.CORE, "ContractValidator", 
				"âœ“ CoreMod uses optional type: '%s'" % optional_type)
	
	# Identify custom types (not in suggestions)
	for contract_type in defined_types:
		var is_known = (contract_type in CONTRACT_TYPE_SUGGESTIONS["common_types"] or 
						contract_type in CONTRACT_TYPE_SUGGESTIONS["optional_types"])
		
		if not is_known:
			LoggingService.info(LoggingService.Context.CORE, "ContractValidator", 
				"â„¹ CoreMod defines custom contract type: '%s'" % contract_type)


func _validate_contract_type(contract_type: String, contracts: Array, result: CompletenessResult) -> void:
	"""
	Dispatch to type-specific validation for known types,
	or generic validation for unknown types.
	"""
	
	match contract_type:
		"events":
			_validate_event_completeness(contracts, result)
		"systems":
			_validate_system_completeness(contracts, result)
		"registries":
			_validate_registry_completeness(contracts, result)
		"ui":
			_validate_ui_completeness(contracts, result)
		"save_hooks":
			_validate_save_hooks_completeness(contracts, result)
		_:
			# Unknown/custom type - validate generic structure only
			_validate_generic_contracts(contract_type, contracts, result)


## ============================================================================
## TYPE-SPECIFIC VALIDATION (Known Types)
## ============================================================================

func _validate_event_completeness(events: Array, result: CompletenessResult) -> void:
	"""
	Validate event contract completeness.
	Ensures all events have required fields.
	"""
	
	for event in events:
		if typeof(event) != TYPE_DICTIONARY:
			continue
		
		var event_id = event.get("id", "unknown")
		
		# Required: id
		if not event.has("id") or event["id"] == "":
			result.add_missing("Event missing 'id' field")
			continue
		
		# Recommended: cancellable flag
		if not event.has("cancellable"):
			result.add_warning("Event '%s' missing 'cancellable' flag (recommended for mod safety)" % event_id)
		
		# Recommended: schema or description
		if not event.has("payload_schema") and not event.has("description"):
			result.add_warning("Event '%s' has no schema or description (recommended for mod developers)" % event_id)
		
		result.contract_count += 1


func _validate_system_completeness(systems: Array, result: CompletenessResult) -> void:
	"""
	Validate system contract completeness.
	Ensures all systems explicitly declare override capability.
	"""
	
	for system in systems:
		if typeof(system) != TYPE_DICTIONARY:
			continue
		
		var system_id = system.get("id", "unknown")
		
		# Required: id
		if not system.has("id") or system["id"] == "":
			result.add_missing("System missing 'id' field")
			continue
		
		# CRITICAL: Every system MUST declare if it's overrideable
		if not system.has("overrideable"):
			result.add_missing("System '%s' missing 'overrideable' declaration (required for mod safety)" % system_id)
		
		# If overrideable, should have override contract
		if system.get("overrideable", false):
			if not system.has("override_contract"):
				result.add_warning("Overrideable system '%s' missing 'override_contract' details (recommended)" % system_id)
		
		# Recommended: description
		if not system.has("description"):
			result.add_warning("System '%s' missing description (recommended for mod developers)" % system_id)
		
		result.contract_count += 1


func _validate_registry_completeness(registries: Array, result: CompletenessResult) -> void:
	"""
	Validate registry contract completeness.
	Ensures registries have schemas.
	"""
	
	for registry in registries:
		if typeof(registry) != TYPE_DICTIONARY:
			continue
		
		var registry_id = registry.get("id", "unknown")
		
		# Required: id
		if not registry.has("id") or registry["id"] == "":
			result.add_missing("Registry missing 'id' field")
			continue
		
		# Recommended: schema
		if not registry.has("schema"):
			result.add_warning("Registry '%s' missing schema definition (recommended for type safety)" % registry_id)
		
		# Recommended: extensible flag
		if not registry.has("extensible"):
			result.add_warning("Registry '%s' missing 'extensible' flag (recommended for mod clarity)" % registry_id)
		
		result.contract_count += 1


func _validate_ui_completeness(ui_contracts: Array, result: CompletenessResult) -> void:
	"""
	Validate UI contract completeness.
	"""
	
	for ui in ui_contracts:
		if typeof(ui) != TYPE_DICTIONARY:
			continue
		
		var ui_id = ui.get("id", "unknown")
		
		# Required: id
		if not ui.has("id") or ui["id"] == "":
			result.add_missing("UI contract missing 'id' field")
			continue
		
		# Recommended: description
		if not ui.has("description"):
			result.add_warning("UI contract '%s' missing description" % ui_id)
		
		result.contract_count += 1


func _validate_save_hooks_completeness(hooks: Array, result: CompletenessResult) -> void:
	"""
	Validate save hook contract completeness.
	"""
	
	for hook in hooks:
		if typeof(hook) != TYPE_DICTIONARY:
			continue
		
		var hook_id = hook.get("id", "unknown")
		
		# Required: id
		if not hook.has("id") or hook["id"] == "":
			result.add_missing("Save hook missing 'id' field")
			continue
		
		result.contract_count += 1


## ============================================================================
## GENERIC VALIDATION (Unknown/Custom Types)
## ============================================================================

func _validate_generic_contracts(contract_type: String, contracts: Array, result: CompletenessResult) -> void:
	"""
	ADDED: Validate unknown/custom contract types.
	
	For custom contract types that Core doesn't recognize,
	validate basic structure only:
	- Must be array of dictionaries
	- Each must have 'id' field
	- That's it - CoreMod defines the rest
	"""
	
	LoggingService.debug(LoggingService.Context.CORE, "ContractValidator", 
		"Validating custom contract type: '%s' (generic validation)" % contract_type)
	
	for contract in contracts:
		if typeof(contract) != TYPE_DICTIONARY:
			result.add_missing("Contract in '%s' must be a dictionary" % contract_type)
			continue
		
		# Only require 'id' field for unknown types
		if not contract.has("id") or contract["id"] == "":
			result.add_missing("Contract in '%s' missing 'id' field" % contract_type)
			continue
		
		var contract_id = contract["id"]
		
		# Suggestion: description is helpful
		if not contract.has("description"):
			result.add_warning("Contract '%s' in type '%s' missing description (recommended)" % [contract_id, contract_type])
		
		result.contract_count += 1
	
	LoggingService.debug(LoggingService.Context.CORE, "ContractValidator", 
		"âœ“ Custom type '%s' has %d contracts" % [contract_type, contracts.size()])


## ============================================================================
## COVERAGE CALCULATION
## ============================================================================

func _calculate_coverage(contracts: Dictionary, result: CompletenessResult) -> void:
	"""
	Calculate contract coverage percentage.
	"""
	
	var total_possible = 0
	var total_defined = 0
	
	# Count defined contracts
	for contract_type in contracts.keys():
		var contract_list = contracts[contract_type]
		if typeof(contract_list) == TYPE_ARRAY:
			total_defined += contract_list.size()
	
	# Estimate total possible (heuristic)
	# This is a rough estimate - actual coverage depends on CoreMod complexity
	total_possible = max(total_defined, result.missing_contracts.size() + total_defined)
	
	if total_possible > 0:
		result.coverage_percentage = (float(total_defined) / float(total_possible)) * 100.0
	else:
		result.coverage_percentage = 0.0


## ============================================================================
## CROSS-REFERENCE VALIDATION
## ============================================================================

func validate_cross_references(coremod_metadata: Dictionary, id_map: Dictionary) -> Array[String]:
	"""
	Validate that all contract references are valid.
	Ensures no dangling references between contracts.
	
	Returns:
		Array of error messages (empty if valid)
	"""
	
	var errors: Array[String] = []
	
	if not coremod_metadata.has("contracts"):
		return errors
	
	var contracts = coremod_metadata["contracts"]
	
	# Collect all defined IDs across all contract types
	var defined_ids = {}
	
	for contract_type in contracts.keys():
		var contract_list = contracts[contract_type]
		if typeof(contract_list) == TYPE_ARRAY:
			for contract in contract_list:
				if typeof(contract) == TYPE_DICTIONARY and contract.has("id"):
					defined_ids[contract["id"]] = contract_type
	
	# Check for references to undefined contracts (known types only)
	if contracts.has("events"):
		_check_event_references(contracts["events"], defined_ids, errors)
	
	if contracts.has("systems"):
		_check_system_references(contracts["systems"], defined_ids, errors)
	
	return errors


func _check_event_references(events: Array, defined_ids: Dictionary, errors: Array[String]) -> void:
	"""
	Check event contracts for dangling references.
	"""
	
	for event in events:
		if typeof(event) != TYPE_DICTIONARY:
			continue
		
		var event_id = event.get("id", "unknown")
		
		# Check if event references other contracts
		if event.has("triggers_system"):
			var system_ref = event["triggers_system"]
			if not defined_ids.has(system_ref):
				errors.append("Event '%s' references undefined system: '%s'" % [event_id, system_ref])


func _check_system_references(systems: Array, defined_ids: Dictionary, errors: Array[String]) -> void:
	"""
	Check system contracts for dangling references.
	"""
	
	for system in systems:
		if typeof(system) != TYPE_DICTIONARY:
			continue
		
		var system_id = system.get("id", "unknown")
		
		# Check if system references registries
		if system.has("uses_registry"):
			var registry_refs = system["uses_registry"]
			if typeof(registry_refs) == TYPE_ARRAY:
				for reg_ref in registry_refs:
					if not defined_ids.has(reg_ref):
						errors.append("System '%s' references undefined registry: '%s'" % [system_id, reg_ref])


## ============================================================================
## MOD COMPATIBILITY VALIDATION
## ============================================================================

func validate_mod_compatibility(mod_metadata: Dictionary, coremod_contracts: Dictionary) -> Array[String]:
	"""
	Validate that mod's requested capabilities exist in CoreMod contracts.
	
	Args:
		mod_metadata: Parsed mod metadata
		coremod_contracts: CoreMod's contract declarations
	
	Returns:
		Array of error messages (empty if compatible)
	"""
	
	var errors: Array[String] = []
	
	if not mod_metadata.has("capabilities"):
		# No capabilities requested - always compatible
		return errors
	
	var requested_caps = mod_metadata["capabilities"]
	
	# Collect all available capabilities from CoreMod contracts
	var available_caps = _extract_available_capabilities(coremod_contracts)
	
	# Check each requested capability
	for cap in requested_caps:
		if typeof(cap) == TYPE_STRING:
			if not cap in available_caps:
				errors.append("Mod requests unavailable capability: '%s'" % cap)
	
	return errors


func _extract_available_capabilities(contracts: Dictionary) -> Array[String]:
	"""
	Extract all available capabilities from CoreMod contracts.
	Works with any contract type (known or custom).
	"""
	
	var capabilities: Array[String] = []
	
	# Events provide subscription capability
	if contracts.has("events"):
		for event in contracts["events"]:
			if typeof(event) == TYPE_DICTIONARY and event.has("id"):
				capabilities.append("event.subscribe." + event["id"])
	
	# Systems provide override capability (if overrideable)
	if contracts.has("systems"):
		for system in contracts["systems"]:
			if typeof(system) == TYPE_DICTIONARY and system.has("id"):
				if system.get("overrideable", false):
					capabilities.append("system.override." + system["id"])
	
	# Registries provide extend capability (if extensible)
	if contracts.has("registries"):
		for registry in contracts["registries"]:
			if typeof(registry) == TYPE_DICTIONARY and registry.has("id"):
				if registry.get("extensible", false):
					capabilities.append("registry.extend." + registry["id"])
	
	# ADDED: Generic capability extraction for custom types
	# Custom types can define their own capability patterns
	for contract_type in contracts.keys():
		# Skip types we already handled
		if contract_type in ["events", "systems", "registries"]:
			continue
		
		var contract_list = contracts[contract_type]
		if typeof(contract_list) == TYPE_ARRAY:
			for contract in contract_list:
				if typeof(contract) == TYPE_DICTIONARY and contract.has("id"):
					# Generic capability format: type.action.id
					# Example: "quests.extend.main_quest"
					capabilities.append("%s.access.%s" % [contract_type, contract["id"]])
	
	return capabilities


## ============================================================================
## DIAGNOSTICS
## ============================================================================

func get_version() -> String:
	return VERSION


func format_completeness_result(result: CompletenessResult) -> String:
	"""
	Format completeness result for logging.
	"""
	
	var output = ""
	output += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"
	output += "   CONTRACT COMPLETENESS REPORT\n"
	output += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"
	output += "Complete:     %s\n" % str(result.complete)
	output += "Contracts:    %d\n" % result.contract_count
	output += "Coverage:     %.1f%%\n" % result.coverage_percentage
	output += "Missing:      %d\n" % result.missing_contracts.size()
	output += "Warnings:     %d\n" % result.warnings.size()
	output += "\n"
	
	# ADDED: Show discovered types
	if not result.discovered_types.is_empty():
		output += "CONTRACT TYPES:\n"
		for contract_type in result.discovered_types:
			var is_common = contract_type in CONTRACT_TYPE_SUGGESTIONS["common_types"]
			var is_optional = contract_type in CONTRACT_TYPE_SUGGESTIONS["optional_types"]
			var type_marker = ""
			if is_common:
				type_marker = " [common]"
			elif is_optional:
				type_marker = " [optional]"
			else:
				type_marker = " [custom]"
			output += "  â€¢ %s%s\n" % [contract_type, type_marker]
		output += "\n"
	
	if not result.missing_contracts.is_empty():
		output += "MISSING CONTRACTS:\n"
		for missing in result.missing_contracts:
			output += "  âœ— %s\n" % missing
		output += "\n"
	
	if not result.warnings.is_empty():
		output += "WARNINGS:\n"
		for warning in result.warnings:
			output += "  âš  %s\n" % warning
		output += "\n"
	
	if result.complete:
		output += "âœ“ All required contracts are complete\n"
	else:
		output += "âœ— Contract completeness validation failed\n"
	
	output += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"
	
	return output


res://axiom-runtime-/core/metadata/ContractValidator.gd.uid

## ContractValidator.gd.uid
## Directory: /axiom-runtime-/core/metadata/ContractValidator.gd.uid
##

uid://clrqo8k26y0f0


res://axiom-runtime-/core/metadata/IDGenerator.gd

## IDGenerator.gd
## Directory: /axiom-runtime-/core/metadata/IDGenerator.gd
##

## IDGenerator.gd
## Phase 5: Metadata & Code Generation - Unique ID generation
## Directory: /core/metadata/IDGenerator.gd
##
## CRITICAL: Generates deterministic, collision-free IDs for contracts
## IDs are semantic-free at Core level - just unique strings

extends Node

const VERSION = "1.0.0"

## ID namespace for different entity types
enum Namespace {
	EVENT,
	SYSTEM,
	REGISTRY,
	CAPABILITY,
	CONTRACT
}

## Generated ID tracking for collision detection
var _generated_ids: Dictionary = {}  # {id: namespace}
var _id_lock: Mutex = Mutex.new()


## ============================================================================
## INITIALIZATION
## ============================================================================

func _ready() -> void:
	LoggingService.info(LoggingService.Context.CORE, "IDGenerator", "Initialized v%s" % VERSION)


## ============================================================================
## ID GENERATION
## ============================================================================

func generate_id(namespace_type: int, base_name: String, context: String = "") -> String:
	"""
	Generate a unique ID for a contract element.
	
	Args:
		namespace_type: Type of entity (EVENT, SYSTEM, etc.) as int
		base_name: Human-readable base name
		context: Optional context (e.g., CoreMod ID)
	
	Returns:
		Unique ID string
	"""
	
	_id_lock.lock()
	
	var prefix = _get_namespace_prefix(namespace_type)
	var sanitized = _sanitize_name(base_name)
	
	# Build ID
	var id_parts = [prefix]
	
	if context != "":
		id_parts.append(_sanitize_name(context))
	
	id_parts.append(sanitized)
	
	var base_id = "_".join(id_parts)
	var final_id = base_id
	var counter = 1
	
	# Handle collisions
	while _generated_ids.has(final_id):
		final_id = "%s_%d" % [base_id, counter]
		counter += 1
	
	# Register ID
	_generated_ids[final_id] = namespace_type
	
	_id_lock.unlock()
	
	LoggingService.verbose(LoggingService.Context.CORE, "IDGenerator", "Generated ID: %s" % final_id)
	
	return final_id


func generate_event_id(event_name: String, coremod_id: String = "") -> String:
	"""
	Generate unique ID for an event.
	Example: "evt_coremod_player_died"
	"""
	return generate_id(Namespace.EVENT, event_name, coremod_id)


func generate_system_id(system_name: String, coremod_id: String = "") -> String:
	"""
	Generate unique ID for a system.
	Example: "sys_coremod_career_progression"
	"""
	return generate_id(Namespace.SYSTEM, system_name, coremod_id)


func generate_registry_id(registry_name: String, coremod_id: String = "") -> String:
	"""
	Generate unique ID for a registry.
	Example: "reg_coremod_careers"
	"""
	return generate_id(Namespace.REGISTRY, registry_name, coremod_id)


func generate_capability_id(capability_name: String, context: String = "") -> String:
	"""
	Generate unique ID for a capability.
	Example: "cap_mod_override_system"
	"""
	return generate_id(Namespace.CAPABILITY, capability_name, context)


func generate_contract_id(contract_name: String, coremod_id: String = "") -> String:
	"""
	Generate unique ID for a contract.
	Example: "con_coremod_career_system"
	"""
	return generate_id(Namespace.CONTRACT, contract_name, coremod_id)


## ============================================================================
## ID VALIDATION
## ============================================================================

func is_id_registered(id: String) -> bool:
	"""
	Check if an ID has already been generated.
	"""
	_id_lock.lock()
	var exists = _generated_ids.has(id)
	_id_lock.unlock()
	return exists


func get_id_namespace(id: String) -> int:
	"""
	Get the namespace of a registered ID.
	Returns -1 if not found.
	"""
	_id_lock.lock()
	var ns = _generated_ids.get(id, -1)
	_id_lock.unlock()
	return ns


func validate_id_format(id: String) -> bool:
	"""
	Validate ID format without checking registration.
	"""
	
	if id == "":
		return false
	
	# Must start with namespace prefix
	var valid_prefixes = ["evt_", "sys_", "reg_", "cap_", "con_"]
	var has_valid_prefix = false
	
	for prefix in valid_prefixes:
		if id.begins_with(prefix):
			has_valid_prefix = true
			break
	
	if not has_valid_prefix:
		return false
	
	# Must contain only alphanumeric, underscore
	var regex = RegEx.new()
	regex.compile("^[a-z]+_[a-zA-Z0-9_]+$")
	return regex.search(id) != null


## ============================================================================
## BATCH OPERATIONS
## ============================================================================

func generate_ids_from_metadata(metadata: Dictionary, coremod_id: String) -> Dictionary:
	"""
	Generate IDs for all contract elements in metadata.
	
	Returns:
		Dictionary mapping original names to generated IDs
	"""
	
	var id_map = {}
	
	if not metadata.has("contracts"):
		return id_map
	
	var contracts = metadata["contracts"]
	
	# Generate event IDs
	if contracts.has("events"):
		for event in contracts["events"]:
			if typeof(event) == TYPE_DICTIONARY and event.has("id"):
				var original_id = event["id"]
				var generated_id = generate_event_id(original_id, coremod_id)
				id_map[original_id] = generated_id
	
	# Generate system IDs
	if contracts.has("systems"):
		for system in contracts["systems"]:
			if typeof(system) == TYPE_DICTIONARY and system.has("id"):
				var original_id = system["id"]
				var generated_id = generate_system_id(original_id, coremod_id)
				id_map[original_id] = generated_id
	
	# Generate registry IDs
	if contracts.has("registries"):
		for registry in contracts["registries"]:
			if typeof(registry) == TYPE_DICTIONARY and registry.has("id"):
				var original_id = registry["id"]
				var generated_id = generate_registry_id(original_id, coremod_id)
				id_map[original_id] = generated_id
	
	return id_map


## ============================================================================
## NAMESPACE HELPERS
## ============================================================================

func _get_namespace_prefix(namespace_type: int) -> String:
	"""
	Get prefix for namespace.
	"""
	match namespace_type:
		Namespace.EVENT:
			return "evt"
		Namespace.SYSTEM:
			return "sys"
		Namespace.REGISTRY:
			return "reg"
		Namespace.CAPABILITY:
			return "cap"
		Namespace.CONTRACT:
			return "con"
		_:
			return "unk"


func _sanitize_name(name: String) -> String:
	"""
	Sanitize name for use in ID.
	Converts to lowercase, replaces spaces/special chars with underscores.
	"""
	
	var sanitized = name.to_lower()
	
	# Replace spaces and special characters with underscores
	var regex = RegEx.new()
	regex.compile("[^a-z0-9_]")
	sanitized = regex.sub(sanitized, "_", true)
	
	# Remove duplicate underscores
	while "__" in sanitized:
		sanitized = sanitized.replace("__", "_")
	
	# Remove leading/trailing underscores
	sanitized = sanitized.strip_edges()
	if sanitized.begins_with("_"):
		sanitized = sanitized.substr(1)
	if sanitized.ends_with("_"):
		sanitized = sanitized.substr(0, sanitized.length() - 1)
	
	return sanitized


## ============================================================================
## RESET & CLEANUP
## ============================================================================

func reset_namespace(namespace_type: int) -> void:
	"""
	Clear all IDs in a specific namespace.
	Used when unloading a CoreMod.
	"""
	
	_id_lock.lock()
	
	var to_remove: Array[String] = []
	
	for id in _generated_ids.keys():
		if _generated_ids[id] == namespace_type:
			to_remove.append(id)
	
	for id in to_remove:
		_generated_ids.erase(id)
	
	_id_lock.unlock()
	
	LoggingService.debug(LoggingService.Context.CORE, "IDGenerator", "Reset namespace %s (%d IDs removed)" % [Namespace.keys()[namespace_type], to_remove.size()])


func reset_all() -> void:
	"""
	Clear all generated IDs.
	Used during shutdown or testing.
	"""
	
	_id_lock.lock()
	var count = _generated_ids.size()
	_generated_ids.clear()
	_id_lock.unlock()
	
	LoggingService.info(LoggingService.Context.CORE, "IDGenerator", "Reset all IDs (%d total)" % count)


## ============================================================================
## DIAGNOSTICS
## ============================================================================

func get_version() -> String:
	return VERSION


func get_statistics() -> String:
	"""
	Get ID generation statistics.
	"""
	
	_id_lock.lock()
	
	var total = _generated_ids.size()
	var by_namespace = {}
	
	for namespace_type in Namespace.values():
		by_namespace[namespace_type] = 0
	
	for id in _generated_ids.keys():
		var ns = _generated_ids[id]
		by_namespace[ns] = by_namespace[ns] + 1
	
	_id_lock.unlock()
	
	var stats = ""
	stats += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"
	stats += "   ID GENERATOR STATISTICS\n"
	stats += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"
	stats += "Total IDs:        %d\n" % total
	stats += "\n"
	stats += "By Namespace:\n"
	
	for namespace_type in Namespace.values():
		var ns_name = Namespace.keys()[namespace_type]
		var count = by_namespace[namespace_type]
		stats += "  %s: %d\n" % [ns_name, count]
	
	stats += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"
	
	return stats


func get_all_ids() -> Array[String]:
	"""
	Get all registered IDs.
	"""
	_id_lock.lock()
	var ids: Array[String] = []
	for id in _generated_ids.keys():
		ids.append(id)
	_id_lock.unlock()
	return ids


func get_ids_by_namespace(namespace_type: int) -> Array[String]:
	"""
	Get all IDs in a specific namespace.
	"""
	_id_lock.lock()
	var ids: Array[String] = []
	for id in _generated_ids.keys():
		if _generated_ids[id] == namespace_type:
			ids.append(id)
	_id_lock.unlock()
	return ids


res://axiom-runtime-/core/metadata/IDGenerator.gd.uid

## IDGenerator.gd.uid
## Directory: /axiom-runtime-/core/metadata/IDGenerator.gd.uid
##

uid://b83xiokdna81t


